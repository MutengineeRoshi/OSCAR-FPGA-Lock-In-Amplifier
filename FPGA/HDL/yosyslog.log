
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2018  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.8+612 (git sha1 c6d8692c, clang 6.0.0-1ubuntu2 -fPIC -Os)


-- Parsing `top_sampling.v' using frontend `verilog' --

1. Executing Verilog-2005 frontend: top_sampling.v
Parsing Verilog input from `top_sampling.v' to AST representation.
Generating RTLIL representation for module `\top_sampling'.
Warning: wire '\adcen' is assigned in a block at top_sampling.v:65.
Warning: wire '\wen_w' is assigned in a block at top_sampling.v:67.
Warning: wire '\wen_w' is assigned in a block at top_sampling.v:71.
Warning: wire '\adcen' is assigned in a block at top_sampling.v:76.
top_sampling.v:47: Warning: Identifier `\done' is implicitly declared.
Successfully finished Verilog frontend.

-- Parsing `sram16x16.v' using frontend `verilog' --

2. Executing Verilog-2005 frontend: sram16x16.v
Parsing Verilog input from `sram16x16.v' to AST representation.
Generating RTLIL representation for module `\sram16x16'.
Successfully finished Verilog frontend.

-- Parsing `adc_host.v' using frontend `verilog' --

3. Executing Verilog-2005 frontend: adc_host.v
Parsing Verilog input from `adc_host.v' to AST representation.
Generating RTLIL representation for module `\adc_host'.
Successfully finished Verilog frontend.

-- Parsing `Flash_to_SRAM.v' using frontend `verilog' --

4. Executing Verilog-2005 frontend: Flash_to_SRAM.v
Parsing Verilog input from `Flash_to_SRAM.v' to AST representation.
Generating RTLIL representation for module `\Flash_to_SRAM'.
Successfully finished Verilog frontend.

-- Parsing `spi_flash_reader.v' using frontend `verilog' --

5. Executing Verilog-2005 frontend: spi_flash_reader.v
Parsing Verilog input from `spi_flash_reader.v' to AST representation.
Generating RTLIL representation for module `\spi_flash_reader'.
Successfully finished Verilog frontend.

-- Parsing `serial_out.v' using frontend `verilog' --

6. Executing Verilog-2005 frontend: serial_out.v
Parsing Verilog input from `serial_out.v' to AST representation.
Generating RTLIL representation for module `\serial_out'.
Successfully finished Verilog frontend.

-- Running command `synth_ice40 -top top_sampling -json yosysout_sampling.json' --

7. Executing SYNTH_ICE40 pass.

7.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/cells_sim.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\SB_IO'.
Generating RTLIL representation for module `\SB_GB_IO'.
Generating RTLIL representation for module `\SB_GB'.
Generating RTLIL representation for module `\SB_LUT4'.
Generating RTLIL representation for module `\SB_CARRY'.
Generating RTLIL representation for module `$__ICE40_FULL_ADDER'.
Generating RTLIL representation for module `\SB_DFF'.
Generating RTLIL representation for module `\SB_DFFE'.
Generating RTLIL representation for module `\SB_DFFSR'.
Generating RTLIL representation for module `\SB_DFFR'.
Generating RTLIL representation for module `\SB_DFFSS'.
Generating RTLIL representation for module `\SB_DFFS'.
Generating RTLIL representation for module `\SB_DFFESR'.
Generating RTLIL representation for module `\SB_DFFER'.
Generating RTLIL representation for module `\SB_DFFESS'.
Generating RTLIL representation for module `\SB_DFFES'.
Generating RTLIL representation for module `\SB_DFFN'.
Generating RTLIL representation for module `\SB_DFFNE'.
Generating RTLIL representation for module `\SB_DFFNSR'.
Generating RTLIL representation for module `\SB_DFFNR'.
Generating RTLIL representation for module `\SB_DFFNSS'.
Generating RTLIL representation for module `\SB_DFFNS'.
Generating RTLIL representation for module `\SB_DFFNESR'.
Generating RTLIL representation for module `\SB_DFFNER'.
Generating RTLIL representation for module `\SB_DFFNESS'.
Generating RTLIL representation for module `\SB_DFFNES'.
Generating RTLIL representation for module `\SB_RAM40_4K'.
Generating RTLIL representation for module `\SB_RAM40_4KNR'.
Generating RTLIL representation for module `\SB_RAM40_4KNW'.
Generating RTLIL representation for module `\SB_RAM40_4KNRNW'.
Generating RTLIL representation for module `\ICESTORM_LC'.
Generating RTLIL representation for module `\SB_PLL40_CORE'.
Generating RTLIL representation for module `\SB_PLL40_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2F_CORE'.
Generating RTLIL representation for module `\SB_PLL40_2F_PAD'.
Generating RTLIL representation for module `\SB_WARMBOOT'.
Generating RTLIL representation for module `\SB_SPRAM256KA'.
Generating RTLIL representation for module `\SB_HFOSC'.
Generating RTLIL representation for module `\SB_LFOSC'.
Generating RTLIL representation for module `\SB_RGBA_DRV'.
Generating RTLIL representation for module `\SB_LED_DRV_CUR'.
Generating RTLIL representation for module `\SB_RGB_DRV'.
Generating RTLIL representation for module `\SB_I2C'.
Generating RTLIL representation for module `\SB_SPI'.
Generating RTLIL representation for module `\SB_LEDDA_IP'.
Generating RTLIL representation for module `\SB_FILTER_50NS'.
Generating RTLIL representation for module `\SB_IO_I3C'.
Generating RTLIL representation for module `\SB_IO_OD'.
Generating RTLIL representation for module `\SB_MAC16'.
Successfully finished Verilog frontend.

7.2. Executing HIERARCHY pass (managing design hierarchy).

7.2.1. Analyzing design hierarchy..
Top module:  \top_sampling
Used module:     \sram16x16
Used module:     \serial_out
Used module:     \adc_host

7.2.2. Analyzing design hierarchy..
Top module:  \top_sampling
Used module:     \sram16x16
Used module:     \serial_out
Used module:     \adc_host
Removing unused module `\spi_flash_reader'.
Removing unused module `\Flash_to_SRAM'.
Removed 2 unused modules.
Mapping positional arguments of cell top_sampling.SRAM (sram16x16).
Mapping positional arguments of cell top_sampling.SPI_not_really (serial_out).
Mapping positional arguments of cell top_sampling.adc_host_hi (adc_host).

7.3. Executing PROC pass (convert processes to netlists).

7.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

7.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

7.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 28 assignments to connections.

7.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\serial_out.$proc$serial_out.v:16$135'.
  Set init value: \dcount = 4'1111
Found init rule in `\serial_out.$proc$serial_out.v:15$134'.
  Set init value: \last_last_sclk = 1'0
Found init rule in `\serial_out.$proc$serial_out.v:15$133'.
  Set init value: \last_sclk = 1'0
Found init rule in `\serial_out.$proc$serial_out.v:12$132'.
  Set init value: \done = 1'0
Found init rule in `\serial_out.$proc$serial_out.v:9$131'.
  Set init value: \addr = 16'0000000000000000
Found init rule in `\serial_out.$proc$serial_out.v:8$130'.
  Set init value: \miso = 1'0
Found init rule in `\adc_host.$proc$adc_host.v:18$62'.
  Set init value: \shiftdata = 16'0000000000000000
Found init rule in `\adc_host.$proc$adc_host.v:17$61'.
  Set init value: \count = 8'00000000
Found init rule in `\adc_host.$proc$adc_host.v:16$60'.
  Set init value: \acq = 1'0
Found init rule in `\adc_host.$proc$adc_host.v:14$59'.
  Set init value: \newdata = 1'0
Found init rule in `\adc_host.$proc$adc_host.v:12$58'.
  Set init value: \data = 16'0000000000000000
Found init rule in `\adc_host.$proc$adc_host.v:9$57'.
  Set init value: \CONVST = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:37$28'.
  Set init value: \addr_adc = 16'1111111111111111
Found init rule in `\top_sampling.$proc$top_sampling.v:33$27'.
  Set init value: \lastdone = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:33$26'.
  Set init value: \holdoff = 1'1
Found init rule in `\top_sampling.$proc$top_sampling.v:33$25'.
  Set init value: \ramfull = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:33$24'.
  Set init value: \loadlookup = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:33$23'.
  Set init value: \rst = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:32$22'.
  Set init value: \count = 0

7.3.5. Executing PROC_ARST pass (detect async resets in processes).

7.3.6. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\serial_out.$proc$serial_out.v:16$135'.
Creating decoders for process `\serial_out.$proc$serial_out.v:15$134'.
Creating decoders for process `\serial_out.$proc$serial_out.v:15$133'.
Creating decoders for process `\serial_out.$proc$serial_out.v:12$132'.
Creating decoders for process `\serial_out.$proc$serial_out.v:9$131'.
Creating decoders for process `\serial_out.$proc$serial_out.v:8$130'.
Creating decoders for process `\serial_out.$proc$serial_out.v:18$119'.
     1/4: $0\done[0:0]
     2/4: $0\dcount[3:0]
     3/4: $0\addr[15:0]
     4/4: $0\miso[0:0]
Creating decoders for process `\adc_host.$proc$adc_host.v:18$62'.
Creating decoders for process `\adc_host.$proc$adc_host.v:17$61'.
Creating decoders for process `\adc_host.$proc$adc_host.v:16$60'.
Creating decoders for process `\adc_host.$proc$adc_host.v:14$59'.
Creating decoders for process `\adc_host.$proc$adc_host.v:12$58'.
Creating decoders for process `\adc_host.$proc$adc_host.v:9$57'.
Creating decoders for process `\adc_host.$proc$adc_host.v:40$56'.
Creating decoders for process `\adc_host.$proc$adc_host.v:24$50'.
     1/5: $0\newdata[0:0]
     2/5: $0\acq[0:0]
     3/5: $0\data[15:0]
     4/5: $0\count[7:0]
     5/5: $0\CONVST[0:0]
Creating decoders for process `\top_sampling.$proc$top_sampling.v:37$28'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$27'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$26'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$25'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$24'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$23'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:32$22'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:22$21'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:21$20'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:17$19'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:58$7'.
     1/6: $0\wen_w[0:0]
     2/6: $0\addr_adc[15:0]
     3/6: $0\adcen[0:0]
     4/6: $0\holdoff[0:0]
     5/6: $0\ramfull[0:0]
     6/6: $0\loadlookup[0:0]

7.3.7. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\top_sampling.\GAIN_A1' from process `\top_sampling.$proc$top_sampling.v:22$21'.
No latch inferred for signal `\top_sampling.\GAIN_A0' from process `\top_sampling.$proc$top_sampling.v:21$20'.
No latch inferred for signal `\top_sampling.\SDI' from process `\top_sampling.$proc$top_sampling.v:17$19'.

7.3.8. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\serial_out.\miso' using process `\serial_out.$proc$serial_out.v:18$119'.
  created $dff cell `$procdff$192' with positive edge clock.
Creating register for signal `\serial_out.\addr' using process `\serial_out.$proc$serial_out.v:18$119'.
  created $dff cell `$procdff$193' with positive edge clock.
Creating register for signal `\serial_out.\done' using process `\serial_out.$proc$serial_out.v:18$119'.
  created $dff cell `$procdff$194' with positive edge clock.
Creating register for signal `\serial_out.\last_sclk' using process `\serial_out.$proc$serial_out.v:18$119'.
  created $dff cell `$procdff$195' with positive edge clock.
Creating register for signal `\serial_out.\last_last_sclk' using process `\serial_out.$proc$serial_out.v:18$119'.
  created $dff cell `$procdff$196' with positive edge clock.
Creating register for signal `\serial_out.\dcount' using process `\serial_out.$proc$serial_out.v:18$119'.
  created $dff cell `$procdff$197' with positive edge clock.
Creating register for signal `\adc_host.\shiftdata' using process `\adc_host.$proc$adc_host.v:40$56'.
  created $dff cell `$procdff$198' with negative edge clock.
Creating register for signal `\adc_host.\CONVST' using process `\adc_host.$proc$adc_host.v:24$50'.
  created $dff cell `$procdff$199' with positive edge clock.
Creating register for signal `\adc_host.\count' using process `\adc_host.$proc$adc_host.v:24$50'.
  created $dff cell `$procdff$200' with positive edge clock.
Creating register for signal `\adc_host.\newdata' using process `\adc_host.$proc$adc_host.v:24$50'.
  created $dff cell `$procdff$201' with positive edge clock.
Creating register for signal `\adc_host.\data' using process `\adc_host.$proc$adc_host.v:24$50'.
  created $dff cell `$procdff$202' with positive edge clock.
Creating register for signal `\adc_host.\acq' using process `\adc_host.$proc$adc_host.v:24$50'.
  created $dff cell `$procdff$203' with positive edge clock.
Creating register for signal `\top_sampling.\count' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$204' with positive edge clock.
Creating register for signal `\top_sampling.\rst' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$205' with positive edge clock.
Creating register for signal `\top_sampling.\loadlookup' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$206' with positive edge clock.
Creating register for signal `\top_sampling.\ramfull' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$207' with positive edge clock.
Creating register for signal `\top_sampling.\holdoff' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$208' with positive edge clock.
Creating register for signal `\top_sampling.\lastdone' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$209' with positive edge clock.
Creating register for signal `\top_sampling.\wen_w' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$210' with positive edge clock.
Creating register for signal `\top_sampling.\adcen' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$211' with positive edge clock.
Creating register for signal `\top_sampling.\addr_adc' using process `\top_sampling.$proc$top_sampling.v:58$7'.
  created $dff cell `$procdff$212' with positive edge clock.

7.3.9. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `serial_out.$proc$serial_out.v:16$135'.
Removing empty process `serial_out.$proc$serial_out.v:15$134'.
Removing empty process `serial_out.$proc$serial_out.v:15$133'.
Removing empty process `serial_out.$proc$serial_out.v:12$132'.
Removing empty process `serial_out.$proc$serial_out.v:9$131'.
Removing empty process `serial_out.$proc$serial_out.v:8$130'.
Found and cleaned up 4 empty switches in `\serial_out.$proc$serial_out.v:18$119'.
Removing empty process `serial_out.$proc$serial_out.v:18$119'.
Removing empty process `adc_host.$proc$adc_host.v:18$62'.
Removing empty process `adc_host.$proc$adc_host.v:17$61'.
Removing empty process `adc_host.$proc$adc_host.v:16$60'.
Removing empty process `adc_host.$proc$adc_host.v:14$59'.
Removing empty process `adc_host.$proc$adc_host.v:12$58'.
Removing empty process `adc_host.$proc$adc_host.v:9$57'.
Removing empty process `adc_host.$proc$adc_host.v:40$56'.
Found and cleaned up 5 empty switches in `\adc_host.$proc$adc_host.v:24$50'.
Removing empty process `adc_host.$proc$adc_host.v:24$50'.
Removing empty process `top_sampling.$proc$top_sampling.v:37$28'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$27'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$26'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$25'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$24'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$23'.
Removing empty process `top_sampling.$proc$top_sampling.v:32$22'.
Removing empty process `top_sampling.$proc$top_sampling.v:22$21'.
Removing empty process `top_sampling.$proc$top_sampling.v:21$20'.
Removing empty process `top_sampling.$proc$top_sampling.v:17$19'.
Found and cleaned up 5 empty switches in `\top_sampling.$proc$top_sampling.v:58$7'.
Removing empty process `top_sampling.$proc$top_sampling.v:58$7'.
Cleaned up 14 empty switches.

7.4. Executing FLATTEN pass (flatten design).
Using template adc_host for cells of type adc_host.
Using template sram16x16 for cells of type sram16x16.
Using template serial_out for cells of type serial_out.
<suppressed ~3 debug messages>
No more expansions possible.
Deleting now unused module serial_out.
Deleting now unused module adc_host.
Deleting now unused module sram16x16.

7.5. Executing TRIBUF pass.

7.6. Executing DEMINOUT pass (demote inout ports to input or output).

7.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.
<suppressed ~5 debug messages>

7.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 9 unused cells and 83 unused wires.
<suppressed ~15 debug messages>

7.9. Executing CHECK pass (checking for obvious problems).
checking module top_sampling..
Warning: Wire top_sampling.\ss is used but has no driver.
Warning: Wire top_sampling.\sck is used but has no driver.
Warning: Wire top_sampling.\mosi is used but has no driver.
found and reported 3 problems.

7.10. Executing OPT pass (performing simple optimizations).

7.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
<suppressed ~36 debug messages>
Removed a total of 12 cells.

7.10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top_sampling..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

7.10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top_sampling.
    New input vector for $reduce_or cell $techmap\SPI_not_really.$reduce_or$serial_out.v:20$120: { \SPI_not_really.addr [0] \SPI_not_really.addr [1] \SPI_not_really.addr [2] \SPI_not_really.addr [3] \SPI_not_really.addr [4] \SPI_not_really.addr [5] \SPI_not_really.addr [6] \SPI_not_really.addr [7] \SPI_not_really.addr [8] \SPI_not_really.addr [9] \SPI_not_really.addr [10] \SPI_not_really.addr [11] \SPI_not_really.addr [12] \SPI_not_really.addr [13] \SPI_not_really.addr [14] \SPI_not_really.addr [15] }
    New ctrl vector for $mux cell $techmap\SPI_not_really.$procmux$152: { }
  Optimizing cells in module \top_sampling.
Performed a total of 2 changes.

7.10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.10.6. Executing OPT_RMDFF pass (remove dff with constant values).
Promoting init spec \count = 0 to constant driver in module top_sampling.
Promoting init spec \rst = 1'0 to constant driver in module top_sampling.
Promoting init spec \loadlookup = 1'0 to constant driver in module top_sampling.
Promoted 3 init specs to constant drivers.

7.10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 1 unused cells and 14 unused wires.
<suppressed ~2 debug messages>

7.10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.10.9. Rerunning OPT passes. (Maybe there is more to do..)

7.10.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top_sampling..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

7.10.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top_sampling.
Performed a total of 0 changes.

7.10.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.10.13. Executing OPT_RMDFF pass (remove dff with constant values).

7.10.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.10.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.10.16. Finished OPT passes. (There is nothing left to do.)

7.11. Executing WREDUCE pass (reducing word size of cells).
Removed top 31 bits (of 32) from port B of cell top_sampling.$add$top_sampling.v:70$13 ($add).
Removed top 16 bits (of 32) from port Y of cell top_sampling.$add$top_sampling.v:70$13 ($add).
Removed top 31 bits (of 32) from port B of cell top_sampling.$techmap\adc_host_hi.$add$adc_host.v:26$51 ($add).
Removed top 24 bits (of 32) from port Y of cell top_sampling.$techmap\adc_host_hi.$add$adc_host.v:26$51 ($add).
Removed top 3 bits (of 8) from port B of cell top_sampling.$techmap\adc_host_hi.$eq$adc_host.v:28$53 ($eq).
Removed top 4 bits (of 8) from port B of cell top_sampling.$techmap\adc_host_hi.$eq$adc_host.v:27$52 ($eq).
Removed top 2 bits (of 8) from port B of cell top_sampling.$techmap\adc_host_hi.$eq$adc_host.v:29$54 ($eq).
Removed top 31 bits (of 32) from mux cell top_sampling.$techmap\adc_host_hi.$ternary$adc_host.v:20$49 ($mux).
Removed top 31 bits (of 32) from port B of cell top_sampling.$techmap\SPI_not_really.$add$serial_out.v:26$127 ($add).
Removed top 16 bits (of 32) from port Y of cell top_sampling.$techmap\SPI_not_really.$add$serial_out.v:26$127 ($add).
Removed top 31 bits (of 32) from port B of cell top_sampling.$techmap\SPI_not_really.$sub$serial_out.v:25$125 ($sub).
Removed top 28 bits (of 32) from port Y of cell top_sampling.$techmap\SPI_not_really.$sub$serial_out.v:25$125 ($sub).
Removed top 16 bits (of 32) from wire top_sampling.$add$top_sampling.v:70$13_Y.
Removed top 16 bits (of 32) from wire top_sampling.$techmap\SPI_not_really.$add$serial_out.v:26$127_Y.
Removed top 28 bits (of 32) from wire top_sampling.$techmap\SPI_not_really.$sub$serial_out.v:25$125_Y.
Removed top 14 bits (of 16) from wire top_sampling.SRAM.rdata_2.

7.12. Executing PEEPOPT pass (run peephole optimizers).

7.13. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 0 unused cells and 4 unused wires.
<suppressed ~1 debug messages>

7.14. Executing SHARE pass (SAT-based resource sharing).

7.15. Executing TECHMAP pass (map to technology primitives).

7.15.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/cmp2lut.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

7.15.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~68 debug messages>

7.16. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.18. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module top_sampling:
  creating $macc model for $add$top_sampling.v:70$13 ($add).
  creating $macc model for $techmap\SPI_not_really.$add$serial_out.v:26$127 ($add).
  creating $macc model for $techmap\SPI_not_really.$sub$serial_out.v:25$125 ($sub).
  creating $macc model for $techmap\adc_host_hi.$add$adc_host.v:26$51 ($add).
  creating $alu model for $macc $techmap\adc_host_hi.$add$adc_host.v:26$51.
  creating $alu model for $macc $techmap\SPI_not_really.$sub$serial_out.v:25$125.
  creating $alu model for $macc $techmap\SPI_not_really.$add$serial_out.v:26$127.
  creating $alu model for $macc $add$top_sampling.v:70$13.
  creating $alu cell for $add$top_sampling.v:70$13: $auto$alumacc.cc:474:replace_alu$217
  creating $alu cell for $techmap\SPI_not_really.$add$serial_out.v:26$127: $auto$alumacc.cc:474:replace_alu$220
  creating $alu cell for $techmap\SPI_not_really.$sub$serial_out.v:25$125: $auto$alumacc.cc:474:replace_alu$223
  creating $alu cell for $techmap\adc_host_hi.$add$adc_host.v:26$51: $auto$alumacc.cc:474:replace_alu$226
  created 4 $alu and 0 $macc cells.

7.19. Executing OPT pass (performing simple optimizations).

7.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top_sampling..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

7.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top_sampling.
Performed a total of 0 changes.

7.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.19.6. Executing OPT_RMDFF pass (remove dff with constant values).

7.19.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.19.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.19.9. Finished OPT passes. (There is nothing left to do.)

7.20. Executing FSM pass (extract and optimize FSM).

7.20.1. Executing FSM_DETECT pass (finding FSMs in design).

7.20.2. Executing FSM_EXTRACT pass (extracting FSM from design).

7.20.3. Executing FSM_OPT pass (simple optimizations of FSMs).

7.20.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.20.5. Executing FSM_OPT pass (simple optimizations of FSMs).

7.20.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

7.20.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

7.20.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

7.21. Executing OPT pass (performing simple optimizations).

7.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.21.3. Executing OPT_RMDFF pass (remove dff with constant values).

7.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.21.5. Finished fast OPT passes.

7.22. Executing MEMORY pass.

7.22.1. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

7.22.2. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.22.3. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

7.22.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.22.5. Executing MEMORY_COLLECT pass (generating $mem cells).

7.23. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.24. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).

7.25. Executing TECHMAP pass (map to technology primitives).

7.25.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/brams_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_RAM4K'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M0'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M123'.
Successfully finished Verilog frontend.

7.25.2. Continuing TECHMAP pass.
No more expansions possible.

7.26. Executing ICE40_BRAMINIT pass.

7.27. Executing OPT pass (performing simple optimizations).

7.27.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.
<suppressed ~5 debug messages>

7.27.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.27.3. Executing OPT_RMDFF pass (remove dff with constant values).

7.27.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

7.27.5. Finished fast OPT passes.

7.28. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

7.29. Executing OPT pass (performing simple optimizations).

7.29.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.29.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.29.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top_sampling..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~15 debug messages>

7.29.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top_sampling.
Performed a total of 0 changes.

7.29.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.29.6. Executing OPT_RMDFF pass (remove dff with constant values).

7.29.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.29.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.29.9. Finished OPT passes. (There is nothing left to do.)

7.30. Executing TECHMAP pass (map to technology primitives).

7.30.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

7.30.2. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/arith_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_ice40_alu'.
Successfully finished Verilog frontend.

7.30.3. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $logic_and.
Using extmapper simplemap for cells of type $mux.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=16\Y_WIDTH=16 for cells of type $alu.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $dff.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=4\B_WIDTH=1\Y_WIDTH=4 for cells of type $alu.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod$constmap:446553370afc6c2aa6cc0b8f657b7f64b237ff7c$paramod$55f49a009a975a30a28fdd971adb6110903d4740\_90_shift_shiftx for cells of type $shiftx.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $pos.
Using extmapper simplemap for cells of type $xor.
No more expansions possible.
<suppressed ~246 debug messages>

7.31. Executing ICE40_OPT pass (performing simple optimizations).

7.31.1. Running ICE40 specific optimizations.

7.31.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.
<suppressed ~159 debug messages>

7.31.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
<suppressed ~36 debug messages>
Removed a total of 12 cells.

7.31.4. Executing OPT_RMDFF pass (remove dff with constant values).

7.31.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 85 unused cells and 81 unused wires.
<suppressed ~86 debug messages>

7.31.6. Rerunning OPT passes. (Removed registers in this run.)

7.31.7. Running ICE40 specific optimizations.
Optimized away SB_CARRY cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[0].carry: CO=\addr_adc [0]
Optimized away SB_CARRY cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[0].carry: CO=\SPI_not_really.addr [0]
Optimized away SB_CARRY cell top_sampling.$auto$alumacc.cc:474:replace_alu$223.slice[0].carry: CO=\SPI_not_really.dcount [0]
Optimized away SB_CARRY cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[0].carry: CO=\adc_host_hi.count [0]
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[1].adder back to logic.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[1].adder back to logic.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$223.slice[1].adder back to logic.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[1].adder back to logic.

7.31.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.
<suppressed ~51 debug messages>

7.31.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
<suppressed ~3 debug messages>
Removed a total of 1 cells.

7.31.10. Executing OPT_RMDFF pass (remove dff with constant values).

7.31.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 0 unused cells and 9 unused wires.
<suppressed ~1 debug messages>

7.31.12. Rerunning OPT passes. (Removed registers in this run.)

7.31.13. Running ICE40 specific optimizations.

7.31.14. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.31.15. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.31.16. Executing OPT_RMDFF pass (remove dff with constant values).

7.31.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.31.18. Finished OPT passes. (There is nothing left to do.)

7.32. Executing DFFSR2DFF pass (mapping DFFSR cells to simpler FFs).

7.33. Executing DFF2DFFE pass (transform $dff to $dffe where applicable).
Selected cell types for direct conversion:
  $_DFF_PP1_ -> $__DFFE_PP1
  $_DFF_PP0_ -> $__DFFE_PP0
  $_DFF_PN1_ -> $__DFFE_PN1
  $_DFF_PN0_ -> $__DFFE_PN0
  $_DFF_NP1_ -> $__DFFE_NP1
  $_DFF_NP0_ -> $__DFFE_NP0
  $_DFF_NN1_ -> $__DFFE_NN1
  $_DFF_NN0_ -> $__DFFE_NN0
  $_DFF_N_ -> $_DFFE_NP_
  $_DFF_P_ -> $_DFFE_PP_
Transforming FF to FF+Enable cells in module top_sampling:
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$497 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\CONVST[0:0] -> \adc_host_hi.CONVST.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$514 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\count[7:0] [0] -> \adc_host_hi.count [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$515 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\count[7:0] [1] -> \adc_host_hi.count [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$516 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\count[7:0] [2] -> \adc_host_hi.count [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$517 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\count[7:0] [3] -> \adc_host_hi.count [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$518 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\count[7:0] [4] -> \adc_host_hi.count [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$519 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\count[7:0] [5] -> \adc_host_hi.count [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$520 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\count[7:0] [6] -> \adc_host_hi.count [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$521 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\count[7:0] [7] -> \adc_host_hi.count [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$522 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [0] -> \adc_host_hi.data [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$523 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [1] -> \adc_host_hi.data [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$524 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [2] -> \adc_host_hi.data [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$525 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [3] -> \adc_host_hi.data [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$526 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [4] -> \adc_host_hi.data [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$527 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [5] -> \adc_host_hi.data [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$528 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [6] -> \adc_host_hi.data [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$529 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [7] -> \adc_host_hi.data [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$530 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [8] -> \adc_host_hi.data [8].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$531 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [9] -> \adc_host_hi.data [9].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$532 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [10] -> \adc_host_hi.data [10].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$533 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [11] -> \adc_host_hi.data [11].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$534 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [12] -> \adc_host_hi.data [12].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$535 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [13] -> \adc_host_hi.data [13].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$536 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [14] -> \adc_host_hi.data [14].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$537 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [15] -> \adc_host_hi.data [15].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$554 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\acq[0:0] -> \adc_host_hi.acq.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$574 to $_DFFE_PP_ for $0\addr_adc[15:0] [0] -> \addr_adc [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$575 to $_DFFE_PP_ for $0\addr_adc[15:0] [1] -> \addr_adc [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$576 to $_DFFE_PP_ for $0\addr_adc[15:0] [2] -> \addr_adc [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$577 to $_DFFE_PP_ for $0\addr_adc[15:0] [3] -> \addr_adc [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$578 to $_DFFE_PP_ for $0\addr_adc[15:0] [4] -> \addr_adc [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$579 to $_DFFE_PP_ for $0\addr_adc[15:0] [5] -> \addr_adc [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$580 to $_DFFE_PP_ for $0\addr_adc[15:0] [6] -> \addr_adc [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$581 to $_DFFE_PP_ for $0\addr_adc[15:0] [7] -> \addr_adc [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$582 to $_DFFE_PP_ for $0\addr_adc[15:0] [8] -> \addr_adc [8].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$583 to $_DFFE_PP_ for $0\addr_adc[15:0] [9] -> \addr_adc [9].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$584 to $_DFFE_PP_ for $0\addr_adc[15:0] [10] -> \addr_adc [10].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$585 to $_DFFE_PP_ for $0\addr_adc[15:0] [11] -> \addr_adc [11].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$586 to $_DFFE_PP_ for $0\addr_adc[15:0] [12] -> \addr_adc [12].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$587 to $_DFFE_PP_ for $0\addr_adc[15:0] [13] -> \addr_adc [13].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$588 to $_DFFE_PP_ for $0\addr_adc[15:0] [14] -> \addr_adc [14].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$589 to $_DFFE_PP_ for $0\addr_adc[15:0] [15] -> \addr_adc [15].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$590 to $_DFFE_PP_ for $0\adcen[0:0] -> \adcen.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$591 to $_DFFE_PP_ for $0\holdoff[0:0] -> \holdoff.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$592 to $_DFFE_PP_ for $0\ramfull[0:0] -> \ramfull.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$616 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\dcount[3:0] [0] -> \SPI_not_really.dcount [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$617 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\dcount[3:0] [1] -> \SPI_not_really.dcount [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$618 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\dcount[3:0] [2] -> \SPI_not_really.dcount [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$619 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\dcount[3:0] [3] -> \SPI_not_really.dcount [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$623 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [0] -> \SPI_not_really.addr [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$624 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [1] -> \SPI_not_really.addr [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$625 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [2] -> \SPI_not_really.addr [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$626 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [3] -> \SPI_not_really.addr [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$627 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [4] -> \SPI_not_really.addr [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$628 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [5] -> \SPI_not_really.addr [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$629 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [6] -> \SPI_not_really.addr [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$630 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [7] -> \SPI_not_really.addr [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$631 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [8] -> \SPI_not_really.addr [8].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$632 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [9] -> \SPI_not_really.addr [9].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$633 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [10] -> \SPI_not_really.addr [10].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$634 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [11] -> \SPI_not_really.addr [11].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$635 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [12] -> \SPI_not_really.addr [12].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$636 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [13] -> \SPI_not_really.addr [13].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$637 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [14] -> \SPI_not_really.addr [14].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$638 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [15] -> \SPI_not_really.addr [15].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$639 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\miso[0:0] -> \SPI_not_really.miso.

7.34. Executing TECHMAP pass (map to technology primitives).

7.34.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Successfully finished Verilog frontend.

7.34.2. Continuing TECHMAP pass.
Using template \$_DFF_P_ for cells of type $_DFF_P_.
Using template \$_DFF_N_ for cells of type $_DFF_N_.
Using template \$_DFFE_PP_ for cells of type $_DFFE_PP_.
No more expansions possible.
<suppressed ~88 debug messages>

7.35. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.
<suppressed ~143 debug messages>

7.36. Executing SIMPLEMAP pass (map simple cells to gate primitives).

7.37. Executing ICE40_FFINIT pass (implement FF init values).
Handling FF init values in top_sampling.
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$638 (SB_DFFE): \SPI_not_really.addr [15] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$349 (SB_DFF): \adc_host_hi.newdata = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$639 (SB_DFFE): \SPI_not_really.miso = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$482 (SB_DFFN): \adc_host_hi.shiftdata [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$483 (SB_DFFN): \adc_host_hi.shiftdata [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$484 (SB_DFFN): \adc_host_hi.shiftdata [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$485 (SB_DFFN): \adc_host_hi.shiftdata [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$486 (SB_DFFN): \adc_host_hi.shiftdata [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$487 (SB_DFFN): \adc_host_hi.shiftdata [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$488 (SB_DFFN): \adc_host_hi.shiftdata [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$489 (SB_DFFN): \adc_host_hi.shiftdata [8] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$490 (SB_DFFN): \adc_host_hi.shiftdata [9] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$491 (SB_DFFN): \adc_host_hi.shiftdata [10] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$492 (SB_DFFN): \adc_host_hi.shiftdata [11] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$493 (SB_DFFN): \adc_host_hi.shiftdata [12] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$494 (SB_DFFN): \adc_host_hi.shiftdata [13] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$495 (SB_DFFN): \adc_host_hi.shiftdata [14] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$481 (SB_DFFN): \adc_host_hi.shiftdata [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$497 (SB_DFFE): \adc_host_hi.CONVST = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$496 (SB_DFFN): \adc_host_hi.shiftdata [15] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$515 (SB_DFFE): \adc_host_hi.count [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$516 (SB_DFFE): \adc_host_hi.count [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$517 (SB_DFFE): \adc_host_hi.count [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$518 (SB_DFFE): \adc_host_hi.count [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$519 (SB_DFFE): \adc_host_hi.count [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$520 (SB_DFFE): \adc_host_hi.count [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$514 (SB_DFFE): \adc_host_hi.count [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$521 (SB_DFFE): \adc_host_hi.count [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$523 (SB_DFFE): \adc_host_hi.data [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$524 (SB_DFFE): \adc_host_hi.data [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$525 (SB_DFFE): \adc_host_hi.data [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$526 (SB_DFFE): \adc_host_hi.data [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$527 (SB_DFFE): \adc_host_hi.data [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$528 (SB_DFFE): \adc_host_hi.data [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$529 (SB_DFFE): \adc_host_hi.data [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$530 (SB_DFFE): \adc_host_hi.data [8] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$531 (SB_DFFE): \adc_host_hi.data [9] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$532 (SB_DFFE): \adc_host_hi.data [10] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$533 (SB_DFFE): \adc_host_hi.data [11] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$534 (SB_DFFE): \adc_host_hi.data [12] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$535 (SB_DFFE): \adc_host_hi.data [13] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$536 (SB_DFFE): \adc_host_hi.data [14] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$522 (SB_DFFE): \adc_host_hi.data [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$554 (SB_DFFE): \adc_host_hi.acq = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$622 (SB_DFF): \SPI_not_really.done = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$573 (SB_DFF): \lastdone = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$537 (SB_DFFE): \adc_host_hi.data [15] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$575 (SB_DFFE): \addr_adc [1] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$576 (SB_DFFE): \addr_adc [2] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$577 (SB_DFFE): \addr_adc [3] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$578 (SB_DFFE): \addr_adc [4] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$579 (SB_DFFE): \addr_adc [5] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$580 (SB_DFFE): \addr_adc [6] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$581 (SB_DFFE): \addr_adc [7] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$582 (SB_DFFE): \addr_adc [8] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$583 (SB_DFFE): \addr_adc [9] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$584 (SB_DFFE): \addr_adc [10] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$585 (SB_DFFE): \addr_adc [11] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$586 (SB_DFFE): \addr_adc [12] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$587 (SB_DFFE): \addr_adc [13] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$588 (SB_DFFE): \addr_adc [14] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$574 (SB_DFFE): \addr_adc [0] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$591 (SB_DFFE): \holdoff = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$592 (SB_DFFE): \ramfull = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$589 (SB_DFFE): \addr_adc [15] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$617 (SB_DFFE): \SPI_not_really.dcount [1] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$618 (SB_DFFE): \SPI_not_really.dcount [2] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$621 (SB_DFF): \SPI_not_really.last_sclk = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$616 (SB_DFFE): \SPI_not_really.dcount [0] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$620 (SB_DFF): \SPI_not_really.last_last_sclk = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$619 (SB_DFFE): \SPI_not_really.dcount [3] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$624 (SB_DFFE): \SPI_not_really.addr [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$625 (SB_DFFE): \SPI_not_really.addr [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$626 (SB_DFFE): \SPI_not_really.addr [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$627 (SB_DFFE): \SPI_not_really.addr [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$628 (SB_DFFE): \SPI_not_really.addr [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$629 (SB_DFFE): \SPI_not_really.addr [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$630 (SB_DFFE): \SPI_not_really.addr [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$631 (SB_DFFE): \SPI_not_really.addr [8] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$632 (SB_DFFE): \SPI_not_really.addr [9] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$633 (SB_DFFE): \SPI_not_really.addr [10] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$634 (SB_DFFE): \SPI_not_really.addr [11] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$635 (SB_DFFE): \SPI_not_really.addr [12] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$636 (SB_DFFE): \SPI_not_really.addr [13] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$637 (SB_DFFE): \SPI_not_really.addr [14] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$623 (SB_DFFE): \SPI_not_really.addr [0] = 0

7.38. Executing ICE40_FFSSR pass (merge synchronous set/reset into FF cells).
Merging set/reset $_MUX_ cells into SB_FFs in top_sampling.
  Merging $auto$simplemap.cc:277:simplemap_mux$480 (A=1'0, B=$techmap\adc_host_hi.$procmux$170_Y, S=\adcen) into $auto$simplemap.cc:420:simplemap_dff$497 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$471 (A=1'0, B=$auto$simplemap.cc:309:simplemap_lut$1005 [1], S=$auto$simplemap.cc:256:simplemap_eqne$430) into $auto$simplemap.cc:420:simplemap_dff$515 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$472 (A=1'0, B=$techmap\adc_host_hi.$add$adc_host.v:26$51_Y [2], S=$auto$simplemap.cc:256:simplemap_eqne$430) into $auto$simplemap.cc:420:simplemap_dff$516 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$473 (A=1'0, B=$techmap\adc_host_hi.$add$adc_host.v:26$51_Y [3], S=$auto$simplemap.cc:256:simplemap_eqne$430) into $auto$simplemap.cc:420:simplemap_dff$517 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$474 (A=1'0, B=$techmap\adc_host_hi.$add$adc_host.v:26$51_Y [4], S=$auto$simplemap.cc:256:simplemap_eqne$430) into $auto$simplemap.cc:420:simplemap_dff$518 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$475 (A=1'0, B=$techmap\adc_host_hi.$add$adc_host.v:26$51_Y [5], S=$auto$simplemap.cc:256:simplemap_eqne$430) into $auto$simplemap.cc:420:simplemap_dff$519 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$476 (A=1'0, B=$techmap\adc_host_hi.$add$adc_host.v:26$51_Y [6], S=$auto$simplemap.cc:256:simplemap_eqne$430) into $auto$simplemap.cc:420:simplemap_dff$520 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$470 (A=1'0, B=$techmap\adc_host_hi.$add$adc_host.v:26$51_Y [0], S=$auto$simplemap.cc:256:simplemap_eqne$430) into $auto$simplemap.cc:420:simplemap_dff$514 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$477 (A=1'0, B=$techmap\adc_host_hi.$add$adc_host.v:26$51_Y [7], S=$auto$simplemap.cc:256:simplemap_eqne$430) into $auto$simplemap.cc:420:simplemap_dff$521 (SB_DFFE).

7.39. Executing ICE40_OPT pass (performing simple optimizations).

7.39.1. Running ICE40 specific optimizations.

7.39.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.
<suppressed ~29 debug messages>

7.39.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
<suppressed ~321 debug messages>
Removed a total of 107 cells.

7.39.4. Executing OPT_RMDFF pass (remove dff with constant values).

7.39.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 10 unused cells and 587 unused wires.
<suppressed ~12 debug messages>

7.39.6. Rerunning OPT passes. (Removed registers in this run.)

7.39.7. Running ICE40 specific optimizations.

7.39.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.39.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.39.10. Executing OPT_RMDFF pass (remove dff with constant values).

7.39.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.39.12. Finished OPT passes. (There is nothing left to do.)

7.40. Executing TECHMAP pass (map to technology primitives).

7.40.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/latches_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/latches_map.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

7.40.2. Continuing TECHMAP pass.
No more expansions possible.

7.41. Executing ABC pass (technology mapping using ABC).

7.41.1. Extracting gate netlist of module `\top_sampling' to `<abc-temp-dir>/input.blif'..
Extracted 242 gates and 380 wires to a netlist network with 137 inputs and 83 outputs.

7.41.1.1. Executing ABC.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: + lutpack -S 1 
ABC: + dress 
ABC: Total number of equiv classes                =      92.
ABC: Participating nodes from both networks       =     209.
ABC: Participating nodes from the first network   =      92. (  60.93 % of nodes)
ABC: Participating nodes from the second network  =     117. (  77.48 % of nodes)
ABC: Node pairs (any polarity)                    =      92. (  60.93 % of names can be moved)
ABC: Node pairs (same polarity)                   =      88. (  58.28 % of names can be moved)
ABC: Total runtime =     0.00 sec
ABC: + write_blif <abc-temp-dir>/output.blif 

7.41.1.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:      150
ABC RESULTS:        internal signals:      160
ABC RESULTS:           input signals:      137
ABC RESULTS:          output signals:       83
Removing temp directory.
Removed 0 unused cells and 262 unused wires.

7.42. Executing ICE40_UNLUT pass (convert SB_LUT4 to $lut).
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[0].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[10].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[11].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[12].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[13].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[14].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[15].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[2].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[3].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[4].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[5].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[6].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[7].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[8].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$217.slice[9].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[0].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[10].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[11].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[12].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[13].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[14].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[15].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[2].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[3].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[4].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[5].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[6].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[7].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[8].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$220.slice[9].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$223.slice[0].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$223.slice[2].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$223.slice[3].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[0].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[2].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[3].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[4].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[5].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[6].adder to $lut.
Mapping SB_LUT4 cell top_sampling.$auto$alumacc.cc:474:replace_alu$226.slice[7].adder to $lut.

7.42.1. Executing OPT_LUT pass (optimize LUTs).
Discovering LUTs.
Number of LUTs:      189
  1-LUT               49
  2-LUT               22
  3-LUT               63
  4-LUT               55
  with \SB_CARRY      32

Eliminating LUTs.
Number of LUTs:      189
  1-LUT               49
  2-LUT               22
  3-LUT               63
  4-LUT               55
  with \SB_CARRY      32

Combining LUTs.
Number of LUTs:      169
  1-LUT               29
  2-LUT               22
  3-LUT               63
  4-LUT               55
  with \SB_CARRY      32

Eliminated 0 LUTs.
Combined 20 LUTs.
<suppressed ~1133 debug messages>

7.42.2. Executing TECHMAP pass (map to technology primitives).

7.42.2.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

7.42.2.2. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=2\LUT=4'0100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00111010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0100000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011101000110011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100101000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01100000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000000000001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100101011001100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000001100000101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011010100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110100110010110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1110111111111111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1000000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=1\LUT=2'01 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00110101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100111110100000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000010111110011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000110000001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0001000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011111101010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111001100000101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100101011111111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0001000100001111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111100011111111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110011001100110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1001100110011001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=1\LUT=2'10 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110011010011001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1001011001101001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111000000010001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100010100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10101100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111000011101110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0111000000000111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111110000001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1010110000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0101001111111111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000010111111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1011101100001111 for cells of type $lut.
No more expansions possible.
<suppressed ~697 debug messages>
Removed 0 unused cells and 341 unused wires.

7.42.3. Executing HIERARCHY pass (managing design hierarchy).

7.42.3.1. Analyzing design hierarchy..
Top module:  \top_sampling

7.42.3.2. Analyzing design hierarchy..
Top module:  \top_sampling
Removed 0 unused modules.

7.42.4. Printing statistics.

=== top_sampling ===

   Number of wires:                211
   Number of wire bits:            551
   Number of public wires:          60
   Number of public wire bits:     283
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                298
     SB_CARRY                       36
     SB_DFF                          6
     SB_DFFE                        57
     SB_DFFESR                       9
     SB_DFFN                        16
     SB_LUT4                       169
     SB_PLL40_CORE                   1
     SB_SPRAM256KA                   4

7.42.5. Executing CHECK pass (checking for obvious problems).
checking module top_sampling..
found and reported 0 problems.

7.42.6. Executing JSON backend.

Warnings: 8 unique messages, 8 total
End of script. Logfile hash: f0746aa4c7
CPU: user 0.70s system 0.04s, MEM: 58.54 MB total, 26.67 MB resident
Yosys 0.8+612 (git sha1 c6d8692c, clang 6.0.0-1ubuntu2 -fPIC -Os)
Time spent: 21% 15x read_verilog (0 sec), 13% 18x opt_clean (0 sec), ...
