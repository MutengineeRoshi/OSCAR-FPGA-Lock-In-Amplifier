
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2019  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.9+1706 (git sha1 81e6b040, x86_64-conda_cos6-linux-gnu-gcc 1.23.0.449-a04d0 -fvisibility-inlines-hidden -fmessage-length=0 -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -fdebug-prefix-map=/tmp/really-long-path/conda/conda-bld/yosys_1579927201458/work=/usr/local/src/conda/yosys-0.9_3096_g81e6b040 -fdebug-prefix-map=/home/norman/anaconda3=/usr/local/src/conda-prefix -fPIC -Os)


-- Parsing `top_sampling.v' using frontend `verilog' --

1. Executing Verilog-2005 frontend: top_sampling.v
Parsing Verilog input from `top_sampling.v' to AST representation.
Generating RTLIL representation for module `\top_sampling'.
Warning: wire '\adcen' is assigned in a block at top_sampling.v:67.
Warning: wire '\adcen' is assigned in a block at top_sampling.v:80.
Successfully finished Verilog frontend.

-- Parsing `../sram16x16.v' using frontend `verilog' --

2. Executing Verilog-2005 frontend: ../sram16x16.v
Parsing Verilog input from `../sram16x16.v' to AST representation.
Generating RTLIL representation for module `\sram16x16'.
Successfully finished Verilog frontend.

-- Parsing `../adc_host.v' using frontend `verilog' --

3. Executing Verilog-2005 frontend: ../adc_host.v
Parsing Verilog input from `../adc_host.v' to AST representation.
Generating RTLIL representation for module `\adc_host'.
Successfully finished Verilog frontend.

-- Parsing `../Flash_to_SRAM.v' using frontend `verilog' --

4. Executing Verilog-2005 frontend: ../Flash_to_SRAM.v
Parsing Verilog input from `../Flash_to_SRAM.v' to AST representation.
Generating RTLIL representation for module `\Flash_to_SRAM'.
Successfully finished Verilog frontend.

-- Parsing `../spi_flash_reader.v' using frontend `verilog' --

5. Executing Verilog-2005 frontend: ../spi_flash_reader.v
Parsing Verilog input from `../spi_flash_reader.v' to AST representation.
Generating RTLIL representation for module `\spi_flash_reader'.
Successfully finished Verilog frontend.

-- Parsing `../serial_out.v' using frontend `verilog' --

6. Executing Verilog-2005 frontend: ../serial_out.v
Parsing Verilog input from `../serial_out.v' to AST representation.
Generating RTLIL representation for module `\serial_out'.
Successfully finished Verilog frontend.

-- Running command `synth_ice40 -top top_sampling -json yosysout_sampling.json' --

7. Executing SYNTH_ICE40 pass.

7.1. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/ice40/cells_sim.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/ice40/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\SB_IO'.
Generating RTLIL representation for module `\SB_GB_IO'.
Generating RTLIL representation for module `\SB_GB'.
Generating RTLIL representation for module `\SB_LUT4'.
Generating RTLIL representation for module `\SB_CARRY'.
Generating RTLIL representation for module `\SB_DFF'.
Generating RTLIL representation for module `\SB_DFFE'.
Generating RTLIL representation for module `\SB_DFFSR'.
Generating RTLIL representation for module `\SB_DFFR'.
Generating RTLIL representation for module `\SB_DFFSS'.
Generating RTLIL representation for module `\SB_DFFS'.
Generating RTLIL representation for module `\SB_DFFESR'.
Generating RTLIL representation for module `\SB_DFFER'.
Generating RTLIL representation for module `\SB_DFFESS'.
Generating RTLIL representation for module `\SB_DFFES'.
Generating RTLIL representation for module `\SB_DFFN'.
Generating RTLIL representation for module `\SB_DFFNE'.
Generating RTLIL representation for module `\SB_DFFNSR'.
Generating RTLIL representation for module `\SB_DFFNR'.
Generating RTLIL representation for module `\SB_DFFNSS'.
Generating RTLIL representation for module `\SB_DFFNS'.
Generating RTLIL representation for module `\SB_DFFNESR'.
Generating RTLIL representation for module `\SB_DFFNER'.
Generating RTLIL representation for module `\SB_DFFNESS'.
Generating RTLIL representation for module `\SB_DFFNES'.
Generating RTLIL representation for module `\SB_RAM40_4K'.
Generating RTLIL representation for module `\SB_RAM40_4KNR'.
Generating RTLIL representation for module `\SB_RAM40_4KNW'.
Generating RTLIL representation for module `\SB_RAM40_4KNRNW'.
Generating RTLIL representation for module `\ICESTORM_LC'.
Generating RTLIL representation for module `\SB_PLL40_CORE'.
Generating RTLIL representation for module `\SB_PLL40_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2F_CORE'.
Generating RTLIL representation for module `\SB_PLL40_2F_PAD'.
Generating RTLIL representation for module `\SB_WARMBOOT'.
Generating RTLIL representation for module `\SB_SPRAM256KA'.
Generating RTLIL representation for module `\SB_HFOSC'.
Generating RTLIL representation for module `\SB_LFOSC'.
Generating RTLIL representation for module `\SB_RGBA_DRV'.
Generating RTLIL representation for module `\SB_LED_DRV_CUR'.
Generating RTLIL representation for module `\SB_RGB_DRV'.
Generating RTLIL representation for module `\SB_I2C'.
Generating RTLIL representation for module `\SB_SPI'.
Generating RTLIL representation for module `\SB_LEDDA_IP'.
Generating RTLIL representation for module `\SB_FILTER_50NS'.
Generating RTLIL representation for module `\SB_IO_I3C'.
Generating RTLIL representation for module `\SB_IO_OD'.
Generating RTLIL representation for module `\SB_MAC16'.
Generating RTLIL representation for module `\ICESTORM_RAM'.
Successfully finished Verilog frontend.

7.2. Executing HIERARCHY pass (managing design hierarchy).

7.2.1. Analyzing design hierarchy..
Top module:  \top_sampling
Used module:     \sram16x16
Used module:     \serial_out
Used module:     \adc_host

7.2.2. Analyzing design hierarchy..
Top module:  \top_sampling
Used module:     \sram16x16
Used module:     \serial_out
Used module:     \adc_host
Removing unused module `\spi_flash_reader'.
Removing unused module `\Flash_to_SRAM'.
Removed 2 unused modules.
Mapping positional arguments of cell top_sampling.SRAM (sram16x16).
Mapping positional arguments of cell top_sampling.SPI_not_really (serial_out).
Mapping positional arguments of cell top_sampling.adc_host_hi (adc_host).

7.3. Executing PROC pass (convert processes to netlists).

7.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

7.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$../adc_host.v:29$51 in module adc_host.
Removed a total of 0 dead cases.

7.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 1 redundant assignment.
Promoted 30 assignments to connections.

7.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\serial_out.$proc$../serial_out.v:16$134'.
  Set init value: \dcount = 4'1111
Found init rule in `\serial_out.$proc$../serial_out.v:15$133'.
  Set init value: \last_last_sclk = 1'0
Found init rule in `\serial_out.$proc$../serial_out.v:15$132'.
  Set init value: \last_sclk = 1'0
Found init rule in `\serial_out.$proc$../serial_out.v:12$131'.
  Set init value: \done = 1'0
Found init rule in `\serial_out.$proc$../serial_out.v:9$130'.
  Set init value: \addr = 16'0000000000000000
Found init rule in `\serial_out.$proc$../serial_out.v:8$129'.
  Set init value: \miso = 1'0
Found init rule in `\adc_host.$proc$../adc_host.v:23$63'.
  Set init value: \shiftdata = 16'0000000000000000
Found init rule in `\adc_host.$proc$../adc_host.v:22$62'.
  Set init value: \count = 8'00000000
Found init rule in `\adc_host.$proc$../adc_host.v:21$61'.
  Set init value: \acq = 1'0
Found init rule in `\adc_host.$proc$../adc_host.v:19$60'.
  Set init value: \newdata = 1'0
Found init rule in `\adc_host.$proc$../adc_host.v:17$59'.
  Set init value: \data = 16'0000000000000000
Found init rule in `\adc_host.$proc$../adc_host.v:14$58'.
  Set init value: \CONVST = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:37$29'.
  Set init value: \addr_adc = 16'1111111111111111
Found init rule in `\top_sampling.$proc$top_sampling.v:33$28'.
  Set init value: \fdatholdoff = 1'1
Found init rule in `\top_sampling.$proc$top_sampling.v:33$27'.
  Set init value: \lastdone = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:33$26'.
  Set init value: \holdoff = 1'1
Found init rule in `\top_sampling.$proc$top_sampling.v:33$25'.
  Set init value: \ramfull = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:33$24'.
  Set init value: \loadlookup = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:33$23'.
  Set init value: \wen_adc = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:33$22'.
  Set init value: \rst = 1'0
Found init rule in `\top_sampling.$proc$top_sampling.v:32$21'.
  Set init value: \count = 0

7.3.5. Executing PROC_ARST pass (detect async resets in processes).

7.3.6. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\serial_out.$proc$../serial_out.v:16$134'.
Creating decoders for process `\serial_out.$proc$../serial_out.v:15$133'.
Creating decoders for process `\serial_out.$proc$../serial_out.v:15$132'.
Creating decoders for process `\serial_out.$proc$../serial_out.v:12$131'.
Creating decoders for process `\serial_out.$proc$../serial_out.v:9$130'.
Creating decoders for process `\serial_out.$proc$../serial_out.v:8$129'.
Creating decoders for process `\serial_out.$proc$../serial_out.v:18$120'.
     1/4: $0\done[0:0]
     2/4: $0\dcount[3:0]
     3/4: $0\addr[15:0]
     4/4: $0\miso[0:0]
Creating decoders for process `\adc_host.$proc$../adc_host.v:23$63'.
Creating decoders for process `\adc_host.$proc$../adc_host.v:22$62'.
Creating decoders for process `\adc_host.$proc$../adc_host.v:21$61'.
Creating decoders for process `\adc_host.$proc$../adc_host.v:19$60'.
Creating decoders for process `\adc_host.$proc$../adc_host.v:17$59'.
Creating decoders for process `\adc_host.$proc$../adc_host.v:14$58'.
Creating decoders for process `\adc_host.$proc$../adc_host.v:46$57'.
Creating decoders for process `\adc_host.$proc$../adc_host.v:29$51'.
     1/5: $0\count[7:0]
     2/5: $0\newdata[0:0]
     3/5: $0\acq[0:0]
     4/5: $0\data[15:0]
     5/5: $0\CONVST[0:0]
Creating decoders for process `\top_sampling.$proc$top_sampling.v:37$29'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$28'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$27'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$26'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$25'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$24'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$23'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:33$22'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:32$21'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:22$20'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:21$19'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:17$18'.
Creating decoders for process `\top_sampling.$proc$top_sampling.v:60$4'.
     1/7: $0\wen_adc[0:0]
     2/7: $0\addr_adc[15:0]
     3/7: $0\adcen[0:0]
     4/7: $0\fdatholdoff[0:0]
     5/7: $0\holdoff[0:0]
     6/7: $0\ramfull[0:0]
     7/7: $0\loadlookup[0:0]

7.3.7. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\top_sampling.\GAIN_A1' from process `\top_sampling.$proc$top_sampling.v:22$20'.
No latch inferred for signal `\top_sampling.\GAIN_A0' from process `\top_sampling.$proc$top_sampling.v:21$19'.
No latch inferred for signal `\top_sampling.\SDI' from process `\top_sampling.$proc$top_sampling.v:17$18'.

7.3.8. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\serial_out.\miso' using process `\serial_out.$proc$../serial_out.v:18$120'.
  created $dff cell `$procdff$314' with positive edge clock.
Creating register for signal `\serial_out.\done' using process `\serial_out.$proc$../serial_out.v:18$120'.
  created $dff cell `$procdff$315' with positive edge clock.
Creating register for signal `\serial_out.\addr' using process `\serial_out.$proc$../serial_out.v:18$120'.
  created $dff cell `$procdff$316' with positive edge clock.
Creating register for signal `\serial_out.\last_sclk' using process `\serial_out.$proc$../serial_out.v:18$120'.
  created $dff cell `$procdff$317' with positive edge clock.
Creating register for signal `\serial_out.\last_last_sclk' using process `\serial_out.$proc$../serial_out.v:18$120'.
  created $dff cell `$procdff$318' with positive edge clock.
Creating register for signal `\serial_out.\dcount' using process `\serial_out.$proc$../serial_out.v:18$120'.
  created $dff cell `$procdff$319' with positive edge clock.
Creating register for signal `\adc_host.\shiftdata' using process `\adc_host.$proc$../adc_host.v:46$57'.
  created $dff cell `$procdff$320' with negative edge clock.
Creating register for signal `\adc_host.\CONVST' using process `\adc_host.$proc$../adc_host.v:29$51'.
  created $dff cell `$procdff$321' with positive edge clock.
Creating register for signal `\adc_host.\count' using process `\adc_host.$proc$../adc_host.v:29$51'.
  created $dff cell `$procdff$322' with positive edge clock.
Creating register for signal `\adc_host.\newdata' using process `\adc_host.$proc$../adc_host.v:29$51'.
  created $dff cell `$procdff$323' with positive edge clock.
Creating register for signal `\adc_host.\data' using process `\adc_host.$proc$../adc_host.v:29$51'.
  created $dff cell `$procdff$324' with positive edge clock.
Creating register for signal `\adc_host.\acq' using process `\adc_host.$proc$../adc_host.v:29$51'.
  created $dff cell `$procdff$325' with positive edge clock.
Creating register for signal `\top_sampling.\count' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$326' with positive edge clock.
Creating register for signal `\top_sampling.\rst' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$327' with positive edge clock.
Creating register for signal `\top_sampling.\wen_adc' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$328' with positive edge clock.
Creating register for signal `\top_sampling.\loadlookup' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$329' with positive edge clock.
Creating register for signal `\top_sampling.\ramfull' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$330' with positive edge clock.
Creating register for signal `\top_sampling.\holdoff' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$331' with positive edge clock.
Creating register for signal `\top_sampling.\lastdone' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$332' with positive edge clock.
Creating register for signal `\top_sampling.\fdatholdoff' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$333' with positive edge clock.
Creating register for signal `\top_sampling.\adcen' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$334' with positive edge clock.
Creating register for signal `\top_sampling.\addr_adc' using process `\top_sampling.$proc$top_sampling.v:60$4'.
  created $dff cell `$procdff$335' with positive edge clock.

7.3.9. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `serial_out.$proc$../serial_out.v:16$134'.
Removing empty process `serial_out.$proc$../serial_out.v:15$133'.
Removing empty process `serial_out.$proc$../serial_out.v:15$132'.
Removing empty process `serial_out.$proc$../serial_out.v:12$131'.
Removing empty process `serial_out.$proc$../serial_out.v:9$130'.
Removing empty process `serial_out.$proc$../serial_out.v:8$129'.
Found and cleaned up 3 empty switches in `\serial_out.$proc$../serial_out.v:18$120'.
Removing empty process `serial_out.$proc$../serial_out.v:18$120'.
Removing empty process `adc_host.$proc$../adc_host.v:23$63'.
Removing empty process `adc_host.$proc$../adc_host.v:22$62'.
Removing empty process `adc_host.$proc$../adc_host.v:21$61'.
Removing empty process `adc_host.$proc$../adc_host.v:19$60'.
Removing empty process `adc_host.$proc$../adc_host.v:17$59'.
Removing empty process `adc_host.$proc$../adc_host.v:14$58'.
Removing empty process `adc_host.$proc$../adc_host.v:46$57'.
Found and cleaned up 5 empty switches in `\adc_host.$proc$../adc_host.v:29$51'.
Removing empty process `adc_host.$proc$../adc_host.v:29$51'.
Removing empty process `top_sampling.$proc$top_sampling.v:37$29'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$28'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$27'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$26'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$25'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$24'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$23'.
Removing empty process `top_sampling.$proc$top_sampling.v:33$22'.
Removing empty process `top_sampling.$proc$top_sampling.v:32$21'.
Removing empty process `top_sampling.$proc$top_sampling.v:22$20'.
Removing empty process `top_sampling.$proc$top_sampling.v:21$19'.
Removing empty process `top_sampling.$proc$top_sampling.v:17$18'.
Found and cleaned up 6 empty switches in `\top_sampling.$proc$top_sampling.v:60$4'.
Removing empty process `top_sampling.$proc$top_sampling.v:60$4'.
Cleaned up 14 empty switches.

7.4. Executing FLATTEN pass (flatten design).
Using template adc_host for cells of type adc_host.
Using template sram16x16 for cells of type sram16x16.
Using template serial_out for cells of type serial_out.
No more expansions possible.
Deleting now unused module serial_out.
Deleting now unused module adc_host.
Deleting now unused module sram16x16.

7.5. Executing TRIBUF pass.

7.6. Executing DEMINOUT pass (demote inout ports to input or output).

7.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 7 unused cells and 85 unused wires.

7.9. Executing CHECK pass (checking for obvious problems).
checking module top_sampling..
Warning: Wire top_sampling.\ss is used but has no driver.
Warning: Wire top_sampling.\sck is used but has no driver.
Warning: Wire top_sampling.\mosi is used but has no driver.
Warning: Wire top_sampling.\R is used but has no driver.
found and reported 4 problems.

7.10. Executing OPT pass (performing simple optimizations).

7.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 11 cells.

7.10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top_sampling..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.

7.10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top_sampling.
    New input vector for $reduce_or cell $techmap\SPI_not_really.$reduce_or$../serial_out.v:20$121: { \SPI_not_really.addr [0] \SPI_not_really.addr [1] \SPI_not_really.addr [2] \SPI_not_really.addr [3] \SPI_not_really.addr [4] \SPI_not_really.addr [5] \SPI_not_really.addr [6] \SPI_not_really.addr [7] \SPI_not_really.addr [8] \SPI_not_really.addr [9] \SPI_not_really.addr [10] \SPI_not_really.addr [11] \SPI_not_really.addr [12] \SPI_not_really.addr [13] \SPI_not_really.addr [14] \SPI_not_really.addr [15] }
  Optimizing cells in module \top_sampling.
Performed a total of 1 changes.

7.10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.10.6. Executing OPT_RMDFF pass (remove dff with constant values).
Promoting init spec \rst = 1'0 to constant driver in module top_sampling.
Promoting init spec \loadlookup = 1'0 to constant driver in module top_sampling.
Promoted 2 init specs to constant drivers.

7.10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 0 unused cells and 11 unused wires.

7.10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.10.9. Rerunning OPT passes. (Maybe there is more to do..)

7.10.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top_sampling..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.

7.10.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top_sampling.
Performed a total of 0 changes.

7.10.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.10.13. Executing OPT_RMDFF pass (remove dff with constant values).

7.10.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.10.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.10.16. Finished OPT passes. (There is nothing left to do.)

7.11. Executing WREDUCE pass (reducing word size of cells).
Removed top 31 bits (of 32) from port B of cell top_sampling.$add$top_sampling.v:63$7 ($add).
Removed top 31 bits (of 32) from port B of cell top_sampling.$add$top_sampling.v:74$12 ($add).
Removed top 16 bits (of 32) from port Y of cell top_sampling.$add$top_sampling.v:74$12 ($add).
Removed top 31 bits (of 32) from mux cell top_sampling.$techmap\adc_host_hi.$ternary$../adc_host.v:25$50 ($mux).
Removed top 31 bits (of 32) from port B of cell top_sampling.$techmap\adc_host_hi.$add$../adc_host.v:31$52 ($add).
Removed top 24 bits (of 32) from port Y of cell top_sampling.$techmap\adc_host_hi.$add$../adc_host.v:31$52 ($add).
Removed top 4 bits (of 8) from port B of cell top_sampling.$techmap\adc_host_hi.$eq$../adc_host.v:33$53 ($eq).
Removed top 3 bits (of 8) from port B of cell top_sampling.$techmap\adc_host_hi.$eq$../adc_host.v:34$54 ($eq).
Removed top 2 bits (of 8) from port B of cell top_sampling.$techmap\adc_host_hi.$eq$../adc_host.v:35$55 ($eq).
Removed top 31 bits (of 32) from port B of cell top_sampling.$techmap\SPI_not_really.$add$../serial_out.v:26$128 ($add).
Removed top 16 bits (of 32) from port Y of cell top_sampling.$techmap\SPI_not_really.$add$../serial_out.v:26$128 ($add).
Removed top 31 bits (of 32) from port B of cell top_sampling.$techmap\SPI_not_really.$sub$../serial_out.v:25$126 ($sub).
Removed top 28 bits (of 32) from port Y of cell top_sampling.$techmap\SPI_not_really.$sub$../serial_out.v:25$126 ($sub).
Removed top 16 bits (of 32) from wire top_sampling.$add$top_sampling.v:74$12_Y.
Removed top 16 bits (of 32) from wire top_sampling.$techmap\SPI_not_really.$add$../serial_out.v:26$128_Y.
Removed top 28 bits (of 32) from wire top_sampling.$techmap\SPI_not_really.$sub$../serial_out.v:25$126_Y.
Removed top 11 bits (of 16) from wire top_sampling.SRAM.rdata_3.

7.12. Executing PEEPOPT pass (run peephole optimizers).

7.13. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 0 unused cells and 4 unused wires.

7.14. Executing SHARE pass (SAT-based resource sharing).

7.15. Executing TECHMAP pass (map to technology primitives).

7.15.1. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/cmp2lut.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

7.15.2. Continuing TECHMAP pass.
No more expansions possible.

7.16. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.18. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module top_sampling:
  creating $macc model for $add$top_sampling.v:63$7 ($add).
  creating $macc model for $add$top_sampling.v:74$12 ($add).
  creating $macc model for $techmap\SPI_not_really.$add$../serial_out.v:26$128 ($add).
  creating $macc model for $techmap\SPI_not_really.$sub$../serial_out.v:25$126 ($sub).
  creating $macc model for $techmap\adc_host_hi.$add$../adc_host.v:31$52 ($add).
  creating $alu model for $macc $techmap\adc_host_hi.$add$../adc_host.v:31$52.
  creating $alu model for $macc $techmap\SPI_not_really.$sub$../serial_out.v:25$126.
  creating $alu model for $macc $techmap\SPI_not_really.$add$../serial_out.v:26$128.
  creating $alu model for $macc $add$top_sampling.v:74$12.
  creating $alu model for $macc $add$top_sampling.v:63$7.
  creating $alu cell for $add$top_sampling.v:63$7: $auto$alumacc.cc:485:replace_alu$340
  creating $alu cell for $add$top_sampling.v:74$12: $auto$alumacc.cc:485:replace_alu$343
  creating $alu cell for $techmap\SPI_not_really.$add$../serial_out.v:26$128: $auto$alumacc.cc:485:replace_alu$346
  creating $alu cell for $techmap\SPI_not_really.$sub$../serial_out.v:25$126: $auto$alumacc.cc:485:replace_alu$349
  creating $alu cell for $techmap\adc_host_hi.$add$../adc_host.v:31$52: $auto$alumacc.cc:485:replace_alu$352
  created 5 $alu and 0 $macc cells.

7.19. Executing OPT pass (performing simple optimizations).

7.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top_sampling..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.

7.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top_sampling.
Performed a total of 0 changes.

7.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.19.6. Executing OPT_RMDFF pass (remove dff with constant values).

7.19.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.19.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.19.9. Finished OPT passes. (There is nothing left to do.)

7.20. Executing FSM pass (extract and optimize FSM).

7.20.1. Executing FSM_DETECT pass (finding FSMs in design).

7.20.2. Executing FSM_EXTRACT pass (extracting FSM from design).

7.20.3. Executing FSM_OPT pass (simple optimizations of FSMs).

7.20.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.20.5. Executing FSM_OPT pass (simple optimizations of FSMs).

7.20.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

7.20.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

7.20.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

7.21. Executing OPT pass (performing simple optimizations).

7.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.21.3. Executing OPT_RMDFF pass (remove dff with constant values).

7.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.21.5. Finished fast OPT passes.

7.22. Executing MEMORY pass.

7.22.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

7.22.2. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

7.22.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.22.4. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

7.22.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.22.6. Executing MEMORY_COLLECT pass (generating $mem cells).

7.23. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.24. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).

7.25. Executing TECHMAP pass (map to technology primitives).

7.25.1. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/ice40/brams_map.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/ice40/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_RAM4K'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M0'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M123'.
Successfully finished Verilog frontend.

7.25.2. Continuing TECHMAP pass.
No more expansions possible.

7.26. Executing ICE40_BRAMINIT pass.

7.27. Executing OPT pass (performing simple optimizations).

7.27.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.27.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.27.3. Executing OPT_RMDFF pass (remove dff with constant values).

7.27.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 0 unused cells and 2 unused wires.

7.27.5. Finished fast OPT passes.

7.28. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

7.29. Executing OPT pass (performing simple optimizations).

7.29.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.29.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.29.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \top_sampling..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.

7.29.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \top_sampling.
Performed a total of 0 changes.

7.29.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.29.6. Executing OPT_RMDFF pass (remove dff with constant values).

7.29.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.29.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.29.9. Finished OPT passes. (There is nothing left to do.)

7.30. Executing ICE40_WRAPCARRY pass (wrap carries).

7.31. Executing TECHMAP pass (map to technology primitives).

7.31.1. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/techmap.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

7.31.2. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/ice40/arith_map.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/ice40/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_ice40_alu'.
Successfully finished Verilog frontend.

7.31.3. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $logic_and.
Using extmapper simplemap for cells of type $mux.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=16\Y_WIDTH=16 for cells of type $alu.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $dff.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=32\Y_WIDTH=32 for cells of type $alu.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=4\B_WIDTH=1\Y_WIDTH=4 for cells of type $alu.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod$constmap:446553370afc6c2aa6cc0b8f657b7f64b237ff7c$paramod$55f49a009a975a30a28fdd971adb6110903d4740\_90_shift_shiftx for cells of type $shiftx.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $pos.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $xor.
No more expansions possible.

7.32. Executing ICE40_OPT pass (performing simple optimizations).

7.32.1. Running ICE40 specific optimizations.

7.32.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.32.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 11 cells.

7.32.4. Executing OPT_RMDFF pass (remove dff with constant values).

7.32.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 114 unused cells and 92 unused wires.

7.32.6. Rerunning OPT passes. (Removed registers in this run.)

7.32.7. Running ICE40 specific optimizations.
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top_sampling.$auto$alumacc.cc:485:replace_alu$340.slice[0].carry: CO=\count [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top_sampling.$auto$alumacc.cc:485:replace_alu$343.slice[0].carry: CO=\addr_adc [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top_sampling.$auto$alumacc.cc:485:replace_alu$346.slice[0].carry: CO=\SPI_not_really.addr [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top_sampling.$auto$alumacc.cc:485:replace_alu$349.slice[0].carry: CO=\SPI_not_really.dcount [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) top_sampling.$auto$alumacc.cc:485:replace_alu$352.slice[0].carry: CO=\adc_host_hi.count [0]

7.32.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.32.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.32.10. Executing OPT_RMDFF pass (remove dff with constant values).

7.32.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.32.12. Rerunning OPT passes. (Removed registers in this run.)

7.32.13. Running ICE40 specific optimizations.

7.32.14. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.32.15. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.32.16. Executing OPT_RMDFF pass (remove dff with constant values).

7.32.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.32.18. Finished OPT passes. (There is nothing left to do.)

7.33. Executing DFFSR2DFF pass (mapping DFFSR cells to simpler FFs).

7.34. Executing DFF2DFFE pass (transform $dff to $dffe where applicable).
Selected cell types for direct conversion:
  $_DFF_PP1_ -> $__DFFE_PP1
  $_DFF_PP0_ -> $__DFFE_PP0
  $_DFF_PN1_ -> $__DFFE_PN1
  $_DFF_PN0_ -> $__DFFE_PN0
  $_DFF_NP1_ -> $__DFFE_NP1
  $_DFF_NP0_ -> $__DFFE_NP0
  $_DFF_NN1_ -> $__DFFE_NN1
  $_DFF_NN0_ -> $__DFFE_NN0
  $_DFF_N_ -> $_DFFE_NP_
  $_DFF_P_ -> $_DFFE_PP_
Transforming FF to FF+Enable cells in module top_sampling:
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$514 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\CONVST[0:0] -> \adc_host_hi.CONVST.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$524 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [0] -> \adc_host_hi.data [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$525 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [1] -> \adc_host_hi.data [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$526 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [2] -> \adc_host_hi.data [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$527 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [3] -> \adc_host_hi.data [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$528 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [4] -> \adc_host_hi.data [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$529 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [5] -> \adc_host_hi.data [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$530 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [6] -> \adc_host_hi.data [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$531 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [7] -> \adc_host_hi.data [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$532 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [8] -> \adc_host_hi.data [8].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$533 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [9] -> \adc_host_hi.data [9].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$534 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [10] -> \adc_host_hi.data [10].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$535 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [11] -> \adc_host_hi.data [11].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$536 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [12] -> \adc_host_hi.data [12].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$537 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [13] -> \adc_host_hi.data [13].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$538 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [14] -> \adc_host_hi.data [14].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$539 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\data[15:0] [15] -> \adc_host_hi.data [15].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$540 to $_DFFE_PP_ for $techmap\adc_host_hi.$0\acq[0:0] -> \adc_host_hi.acq.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$541 to $_DFFE_PP_ for $0\addr_adc[15:0] [0] -> \addr_adc [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$542 to $_DFFE_PP_ for $0\addr_adc[15:0] [1] -> \addr_adc [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$543 to $_DFFE_PP_ for $0\addr_adc[15:0] [2] -> \addr_adc [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$544 to $_DFFE_PP_ for $0\addr_adc[15:0] [3] -> \addr_adc [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$545 to $_DFFE_PP_ for $0\addr_adc[15:0] [4] -> \addr_adc [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$546 to $_DFFE_PP_ for $0\addr_adc[15:0] [5] -> \addr_adc [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$547 to $_DFFE_PP_ for $0\addr_adc[15:0] [6] -> \addr_adc [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$548 to $_DFFE_PP_ for $0\addr_adc[15:0] [7] -> \addr_adc [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$549 to $_DFFE_PP_ for $0\addr_adc[15:0] [8] -> \addr_adc [8].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$550 to $_DFFE_PP_ for $0\addr_adc[15:0] [9] -> \addr_adc [9].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$551 to $_DFFE_PP_ for $0\addr_adc[15:0] [10] -> \addr_adc [10].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$552 to $_DFFE_PP_ for $0\addr_adc[15:0] [11] -> \addr_adc [11].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$553 to $_DFFE_PP_ for $0\addr_adc[15:0] [12] -> \addr_adc [12].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$554 to $_DFFE_PP_ for $0\addr_adc[15:0] [13] -> \addr_adc [13].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$555 to $_DFFE_PP_ for $0\addr_adc[15:0] [14] -> \addr_adc [14].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$556 to $_DFFE_PP_ for $0\addr_adc[15:0] [15] -> \addr_adc [15].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$557 to $_DFFE_PP_ for $0\adcen[0:0] -> \adcen.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$558 to $_DFFE_PP_ for $0\fdatholdoff[0:0] -> \fdatholdoff.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$560 to $_DFFE_PP_ for $0\holdoff[0:0] -> \holdoff.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$561 to $_DFFE_PP_ for $0\ramfull[0:0] -> \ramfull.
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$763 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\dcount[3:0] [0] -> \SPI_not_really.dcount [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$764 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\dcount[3:0] [1] -> \SPI_not_really.dcount [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$765 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\dcount[3:0] [2] -> \SPI_not_really.dcount [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$766 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\dcount[3:0] [3] -> \SPI_not_really.dcount [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$769 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [0] -> \SPI_not_really.addr [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$770 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [1] -> \SPI_not_really.addr [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$771 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [2] -> \SPI_not_really.addr [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$772 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [3] -> \SPI_not_really.addr [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$773 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [4] -> \SPI_not_really.addr [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$774 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [5] -> \SPI_not_really.addr [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$775 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [6] -> \SPI_not_really.addr [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$776 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [7] -> \SPI_not_really.addr [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$777 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [8] -> \SPI_not_really.addr [8].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$778 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [9] -> \SPI_not_really.addr [9].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$779 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [10] -> \SPI_not_really.addr [10].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$780 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [11] -> \SPI_not_really.addr [11].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$781 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [12] -> \SPI_not_really.addr [12].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$782 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [13] -> \SPI_not_really.addr [13].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$783 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [14] -> \SPI_not_really.addr [14].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$784 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\addr[15:0] [15] -> \SPI_not_really.addr [15].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$786 to $_DFFE_PP_ for $techmap\SPI_not_really.$0\miso[0:0] -> \SPI_not_really.miso.

7.35. Executing TECHMAP pass (map to technology primitives).

7.35.1. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Successfully finished Verilog frontend.

7.35.2. Continuing TECHMAP pass.
Using template \$_DFF_N_ for cells of type $_DFF_N_.
Using template \$_DFFE_PP_ for cells of type $_DFFE_PP_.
Using template \$_DFF_P_ for cells of type $_DFF_P_.
No more expansions possible.

7.36. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.37. Executing SIMPLEMAP pass (map simple cells to gate primitives).
Mapping top_sampling.$auto$alumacc.cc:485:replace_alu$340.slice[0].carry ($lut).
Mapping top_sampling.$auto$alumacc.cc:485:replace_alu$343.slice[0].carry ($lut).
Mapping top_sampling.$auto$alumacc.cc:485:replace_alu$346.slice[0].carry ($lut).
Mapping top_sampling.$auto$alumacc.cc:485:replace_alu$349.slice[0].carry ($lut).
Mapping top_sampling.$auto$alumacc.cc:485:replace_alu$352.slice[0].carry ($lut).

7.38. Executing ICE40_FFINIT pass (implement FF init values).
Handling FF init values in top_sampling.
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$784 (SB_DFFE): \SPI_not_really.addr [15] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$786 (SB_DFFE): \SPI_not_really.miso = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$499 (SB_DFFN): \adc_host_hi.shiftdata [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$500 (SB_DFFN): \adc_host_hi.shiftdata [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$501 (SB_DFFN): \adc_host_hi.shiftdata [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$502 (SB_DFFN): \adc_host_hi.shiftdata [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$503 (SB_DFFN): \adc_host_hi.shiftdata [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$504 (SB_DFFN): \adc_host_hi.shiftdata [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$505 (SB_DFFN): \adc_host_hi.shiftdata [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$506 (SB_DFFN): \adc_host_hi.shiftdata [8] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$507 (SB_DFFN): \adc_host_hi.shiftdata [9] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$508 (SB_DFFN): \adc_host_hi.shiftdata [10] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$509 (SB_DFFN): \adc_host_hi.shiftdata [11] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$510 (SB_DFFN): \adc_host_hi.shiftdata [12] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$511 (SB_DFFN): \adc_host_hi.shiftdata [13] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$512 (SB_DFFN): \adc_host_hi.shiftdata [14] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$498 (SB_DFFN): \adc_host_hi.shiftdata [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$514 (SB_DFFE): \adc_host_hi.CONVST = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$513 (SB_DFFN): \adc_host_hi.shiftdata [15] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$516 (SB_DFF): \adc_host_hi.count [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$517 (SB_DFF): \adc_host_hi.count [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$518 (SB_DFF): \adc_host_hi.count [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$519 (SB_DFF): \adc_host_hi.count [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$520 (SB_DFF): \adc_host_hi.count [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$521 (SB_DFF): \adc_host_hi.count [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$515 (SB_DFF): \adc_host_hi.count [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$523 (SB_DFF): \adc_host_hi.newdata = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$522 (SB_DFF): \adc_host_hi.count [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$525 (SB_DFFE): \adc_host_hi.data [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$526 (SB_DFFE): \adc_host_hi.data [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$527 (SB_DFFE): \adc_host_hi.data [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$528 (SB_DFFE): \adc_host_hi.data [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$529 (SB_DFFE): \adc_host_hi.data [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$530 (SB_DFFE): \adc_host_hi.data [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$531 (SB_DFFE): \adc_host_hi.data [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$532 (SB_DFFE): \adc_host_hi.data [8] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$533 (SB_DFFE): \adc_host_hi.data [9] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$534 (SB_DFFE): \adc_host_hi.data [10] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$535 (SB_DFFE): \adc_host_hi.data [11] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$536 (SB_DFFE): \adc_host_hi.data [12] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$537 (SB_DFFE): \adc_host_hi.data [13] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$538 (SB_DFFE): \adc_host_hi.data [14] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$524 (SB_DFFE): \adc_host_hi.data [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$540 (SB_DFFE): \adc_host_hi.acq = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$539 (SB_DFFE): \adc_host_hi.data [15] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$542 (SB_DFFE): \addr_adc [1] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$543 (SB_DFFE): \addr_adc [2] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$544 (SB_DFFE): \addr_adc [3] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$545 (SB_DFFE): \addr_adc [4] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$546 (SB_DFFE): \addr_adc [5] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$547 (SB_DFFE): \addr_adc [6] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$548 (SB_DFFE): \addr_adc [7] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$549 (SB_DFFE): \addr_adc [8] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$550 (SB_DFFE): \addr_adc [9] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$551 (SB_DFFE): \addr_adc [10] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$552 (SB_DFFE): \addr_adc [11] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$553 (SB_DFFE): \addr_adc [12] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$554 (SB_DFFE): \addr_adc [13] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$555 (SB_DFFE): \addr_adc [14] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$541 (SB_DFFE): \addr_adc [0] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$785 (SB_DFF): \SPI_not_really.done = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$559 (SB_DFF): \lastdone = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$560 (SB_DFFE): \holdoff = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$561 (SB_DFFE): \ramfull = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$562 (SB_DFF): \wen_adc = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$556 (SB_DFFE): \addr_adc [15] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$564 (SB_DFF): \count [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$565 (SB_DFF): \count [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$566 (SB_DFF): \count [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$567 (SB_DFF): \count [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$568 (SB_DFF): \count [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$569 (SB_DFF): \count [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$570 (SB_DFF): \count [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$571 (SB_DFF): \count [8] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$572 (SB_DFF): \count [9] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$573 (SB_DFF): \count [10] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$574 (SB_DFF): \count [11] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$575 (SB_DFF): \count [12] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$576 (SB_DFF): \count [13] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$577 (SB_DFF): \count [14] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$578 (SB_DFF): \count [15] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$579 (SB_DFF): \count [16] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$580 (SB_DFF): \count [17] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$581 (SB_DFF): \count [18] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$582 (SB_DFF): \count [19] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$583 (SB_DFF): \count [20] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$584 (SB_DFF): \count [21] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$585 (SB_DFF): \count [22] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$586 (SB_DFF): \count [23] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$587 (SB_DFF): \count [24] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$588 (SB_DFF): \count [25] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$589 (SB_DFF): \count [26] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$590 (SB_DFF): \count [27] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$591 (SB_DFF): \count [28] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$592 (SB_DFF): \count [29] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$593 (SB_DFF): \count [30] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$594 (SB_DFF): \count [31] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$763 (SB_DFFE): \SPI_not_really.dcount [0] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$764 (SB_DFFE): \SPI_not_really.dcount [1] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$765 (SB_DFFE): \SPI_not_really.dcount [2] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$768 (SB_DFF): \SPI_not_really.last_sclk = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$773 (SB_DFFE): \SPI_not_really.addr [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$767 (SB_DFF): \SPI_not_really.last_last_sclk = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$766 (SB_DFFE): \SPI_not_really.dcount [3] = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$770 (SB_DFFE): \SPI_not_really.addr [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$771 (SB_DFFE): \SPI_not_really.addr [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$563 (SB_DFF): \count [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$772 (SB_DFFE): \SPI_not_really.addr [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$774 (SB_DFFE): \SPI_not_really.addr [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$775 (SB_DFFE): \SPI_not_really.addr [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$776 (SB_DFFE): \SPI_not_really.addr [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$777 (SB_DFFE): \SPI_not_really.addr [8] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$778 (SB_DFFE): \SPI_not_really.addr [9] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$779 (SB_DFFE): \SPI_not_really.addr [10] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$780 (SB_DFFE): \SPI_not_really.addr [11] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$781 (SB_DFFE): \SPI_not_really.addr [12] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$782 (SB_DFFE): \SPI_not_really.addr [13] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$783 (SB_DFFE): \SPI_not_really.addr [14] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$558 (SB_DFFE): \fdatholdoff = 1
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$769 (SB_DFFE): \SPI_not_really.addr [0] = 0

7.39. Executing ICE40_FFSSR pass (merge synchronous set/reset into FF cells).
Merging set/reset $_MUX_ cells into SB_FFs in top_sampling.
  Merging $auto$simplemap.cc:277:simplemap_mux$705 (A=1'0, B=$techmap\adc_host_hi.$procmux$288_Y, S=\adcen) into $auto$simplemap.cc:420:simplemap_dff$514 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$678 (A=1'0, B=$techmap\adc_host_hi.$procmux$274_Y [1], S=$auto$simplemap.cc:256:simplemap_eqne$655) into $auto$simplemap.cc:420:simplemap_dff$516 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$679 (A=1'0, B=$techmap\adc_host_hi.$procmux$274_Y [2], S=$auto$simplemap.cc:256:simplemap_eqne$655) into $auto$simplemap.cc:420:simplemap_dff$517 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$680 (A=1'0, B=$techmap\adc_host_hi.$procmux$274_Y [3], S=$auto$simplemap.cc:256:simplemap_eqne$655) into $auto$simplemap.cc:420:simplemap_dff$518 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$681 (A=1'0, B=$techmap\adc_host_hi.$procmux$274_Y [4], S=$auto$simplemap.cc:256:simplemap_eqne$655) into $auto$simplemap.cc:420:simplemap_dff$519 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$682 (A=1'0, B=$techmap\adc_host_hi.$procmux$274_Y [5], S=$auto$simplemap.cc:256:simplemap_eqne$655) into $auto$simplemap.cc:420:simplemap_dff$520 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$683 (A=1'0, B=$techmap\adc_host_hi.$procmux$274_Y [6], S=$auto$simplemap.cc:256:simplemap_eqne$655) into $auto$simplemap.cc:420:simplemap_dff$521 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$677 (A=1'0, B=$techmap\adc_host_hi.$procmux$274_Y [0], S=$auto$simplemap.cc:256:simplemap_eqne$655) into $auto$simplemap.cc:420:simplemap_dff$515 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$684 (A=1'0, B=$techmap\adc_host_hi.$procmux$274_Y [7], S=$auto$simplemap.cc:256:simplemap_eqne$655) into $auto$simplemap.cc:420:simplemap_dff$522 (SB_DFF).

7.40. Executing ICE40_OPT pass (performing simple optimizations).

7.40.1. Running ICE40 specific optimizations.

7.40.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.40.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 96 cells.

7.40.4. Executing OPT_RMDFF pass (remove dff with constant values).

7.40.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..
Removed 11 unused cells and 667 unused wires.

7.40.6. Rerunning OPT passes. (Removed registers in this run.)

7.40.7. Running ICE40 specific optimizations.

7.40.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module top_sampling.

7.40.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\top_sampling'.
Removed a total of 0 cells.

7.40.10. Executing OPT_RMDFF pass (remove dff with constant values).

7.40.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \top_sampling..

7.40.12. Finished OPT passes. (There is nothing left to do.)

7.41. Executing TECHMAP pass (map to technology primitives).

7.41.1. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/ice40/latches_map.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/ice40/latches_map.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

7.41.2. Continuing TECHMAP pass.
No more expansions possible.

7.42. Executing ABC pass (technology mapping using ABC).

7.42.1. Extracting gate netlist of module `\top_sampling' to `<abc-temp-dir>/input.blif'..
Extracted 237 gates and 384 wires to a netlist network with 146 inputs and 85 outputs.

7.42.1.1. Executing ABC.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: + lutpack -S 1 
ABC: + dress 
ABC: Total number of equiv classes                =      94.
ABC: Participating nodes from both networks       =     213.
ABC: Participating nodes from the first network   =      95. (  60.90 % of nodes)
ABC: Participating nodes from the second network  =     118. (  75.64 % of nodes)
ABC: Node pairs (any polarity)                    =      95. (  60.90 % of names can be moved)
ABC: Node pairs (same polarity)                   =      88. (  56.41 % of names can be moved)
ABC: Total runtime =     0.00 sec
ABC: + write_blif <abc-temp-dir>/output.blif 

7.42.1.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:      155
ABC RESULTS:        internal signals:      153
ABC RESULTS:           input signals:      146
ABC RESULTS:          output signals:       85
Removing temp directory.

7.43. Executing ICE40_WRAPCARRY pass (wrap carries).

7.44. Executing TECHMAP pass (map to technology primitives).

7.44.1. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Successfully finished Verilog frontend.

7.44.2. Continuing TECHMAP pass.
No more expansions possible.
Removed 29 unused cells and 261 unused wires.

7.45. Executing OPT_LUT pass (optimize LUTs).
Discovering LUTs.
Number of LUTs:      217
  1-LUT               42
  2-LUT               27
  3-LUT               93
  4-LUT               55
  with \SB_CARRY      58

Eliminating LUTs.
Number of LUTs:      217
  1-LUT               42
  2-LUT               27
  3-LUT               93
  4-LUT               55
  with \SB_CARRY      58

Combining LUTs.
Number of LUTs:      190
  1-LUT               22
  2-LUT               19
  3-LUT               88
  4-LUT               61
  with \SB_CARRY      58

Eliminated 0 LUTs.
Combined 27 LUTs.

7.46. Executing TECHMAP pass (map to technology primitives).

7.46.1. Executing Verilog-2005 frontend: /home/norman/anaconda3/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/home/norman/anaconda3/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

7.46.2. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=3\LUT=8'11001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011101000110011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011010100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00111010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100101000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000110000001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000011101111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00110101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01010011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000001100000101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000011100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111111000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=1\LUT=2'01 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000000000001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1110111111111111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0111000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110100110010110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110011001100110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1001100110011001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0001000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000011111110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1000000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110011010011001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110011000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0100000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01100000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100111110100000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111110000001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'10101100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0011111101010000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111001100000101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0001000111110000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111110011110101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000101011111100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100110011000101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1011001100111111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111101011111100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1011000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111010000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1010000011001111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1100001100010101 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111001111111010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1000111100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1111100011111111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1001011001101001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110000001100000 for cells of type $lut.
No more expansions possible.
Removed 0 unused cells and 390 unused wires.

7.47. Executing AUTONAME pass.
Renamed 3117 objects in module top_sampling (23 iterations).

7.48. Executing HIERARCHY pass (managing design hierarchy).

7.48.1. Analyzing design hierarchy..
Top module:  \top_sampling

7.48.2. Analyzing design hierarchy..
Top module:  \top_sampling
Removed 0 unused modules.

7.49. Printing statistics.

=== top_sampling ===

   Number of wires:                217
   Number of wire bits:            591
   Number of public wires:         217
   Number of public wire bits:     591
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                365
     SB_CARRY                       58
     SB_DFF                         30
     SB_DFFE                        58
     SB_DFFESR                       1
     SB_DFFN                        16
     SB_DFFSR                        8
     SB_LUT4                       190
     SB_SPRAM256KA                   4

7.50. Executing CHECK pass (checking for obvious problems).
checking module top_sampling..
found and reported 0 problems.

7.51. Executing JSON backend.

Warnings: 6 unique messages, 6 total
End of script. Logfile hash: 0b6b14e051, CPU: user 1.13s system 0.03s, MEM: 48.03 MB peak
Yosys 0.9+1706 (git sha1 81e6b040, x86_64-conda_cos6-linux-gnu-gcc 1.23.0.449-a04d0 -fvisibility-inlines-hidden -fmessage-length=0 -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -fdebug-prefix-map=/tmp/really-long-path/conda/conda-bld/yosys_1579927201458/work=/usr/local/src/conda/yosys-0.9_3096_g81e6b040 -fdebug-prefix-map=/home/norman/anaconda3=/usr/local/src/conda-prefix -fPIC -Os)
Time spent: 22% 16x read_verilog (0 sec), 15% 18x opt_expr (0 sec), ...
